{
    "projects": {
        "type": "GroupsSection",
        "title": "Proyectos",
        "elements" : [
            {
                "title": "Mecanismo de crowdsourcing automatizado para museo virtual",
                "mediaType": "image",
                "src": "https://saduewa.dcc.uchile.cl/crowdsourcing/gifs/videoForMeshing.gif",
                "alt": "crowdsourcing",
                "descriptionData": {
                    "description": ["Para mi trabajo de título, diseñé e implementé un sistema de crowdsourcing para museos virtuales. Consiste en un sitio web donde los usuarios pueden subir videos e información sobre las obras a exhibir, lo que permite la generación automática de un modelo 3D del objeto, el cual se añade (junto con su información) al museo virtual. Este proyecto involucra aspectos de frontend, backend, Machine Learning y Computación gráfica, ya que, es necesario un sitio web en el que los usuarios suban los videos para procesarlos Backend, de tal modo que se obtengan representaciones tridimensionales reconocibles por el motor gráfico. Todo este proceso está automatizado se usa, ", " para obtener las representaciones tridimensionales."],
                    "components": [
                        {
                            "type": "link",
                            "name": "Gaussian Splatting",
                            "url": "https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/"
                        }
                    ]
                },
                "technologies": [
                    {
                        "name": "Svelte",
                        "icon": "svelte.png",
                        "url": "https://svelte.dev/"
                    },
                    {
                        "name": "FastAPI",
                        "icon": "fastapi.png",
                        "url": "https://fastapi.tiangolo.com/"
                    },
                    {
                        "name": "SQLite",
                        "icon": "sqlite.svg",
                        "url": "https://www.sqlite.org/index.html"
                    },
                    {
                        "name": "Bash",
                        "icon": "bash.png",
                        "url": "https://www.gnu.org/software/bash/"
                    },
                    {
                        "name": "Unity",
                        "icon": "unity.png",
                        "url": "https://unity.com/"
                    }
                ]
            },
            {
                "title": "Comunicación inalámbrica entre Raspberry Pi y esp32",
                "description": "Se manejó la transferencia de paquetes entre una Raspberry Pi y una esp32 mediante distintos protocolos de comunicación. Se pueden enviar paquetes por Wi-Fi usando sockets TCP/UDP, y por BLE usando el protocolo GATT. Esto fue hecho usando Python por el lado de la Raspberry y C++ por el lado de la esp32 (con ESP-IDF). Cabe destacar que se creó una interfaz gráfica (con PyQt) para poder cambiar los protocolos de comunicación y visualizar los resultados.",
                "url": "https://github.com/f-escarate/IoT",
                "technologies": [
                    {
                        "name": "Python",
                        "icon": "python.webp",
                        "url": "https://www.python.org/"
                    },
                    {
                        "name": "C++",
                        "icon": "cpp.png",
                        "url": "https://isocpp.org/"
                    },
                    {
                        "name": "PyQt",
                        "icon": "pyqt.png",
                        "url": "https://riverbankcomputing.com/software/pyqt/intro"
                    },
                    {
                        "name": "ESP-IDF",
                        "icon": "espressif.png",
                        "url": "https://docs.espressif.com/projects/esp-idf/en/latest/esp32/"
                    }
                ]
            },
            {
                "title": "Visualizador de datos de sensores Bosch",
                "description": "Se creó una interfaz gráfica (con PyQt) para poder visualizar datos obtenidos por sensores, y editar sus configuraciones. Esto era posible conectando la esp32 por USB a un computador para que se comunicaran a través de UART. Los sensores utilizados fueron el BME688 (sensor de calidad del aire) y el BMI270 (IMU). Se usó el framework ESP-IDF y comunicación I2C.",
                "url": "https://github.com/f-escarate/EmbebidosYSensores",
                "technologies": [
                    {
                        "name": "C++",
                        "icon": "cpp.png",
                        "url": "https://isocpp.org/"
                    },
                    {
                        "name": "PyQt",
                        "icon": "pyqt.png",
                        "url": "https://riverbankcomputing.com/software/pyqt/intro"
                    },
                    {
                        "name": "ESP-IDF",
                        "icon": "espressif.png",
                        "url": "https://docs.espressif.com/projects/esp-idf/en/latest/esp32/"
                    }
                ]
            },
            {
                "title": "Aplicación de inventario",
                "description": "Aplicación hecha para dispositivos Android. Permite llevar un control de los productos que hay en la despensa. Está hecha con React Native, Golang y MongoDB.",
                "url": "https://github.com/f-escarate/InventoryApp",
                "technologies": [
                    {
                        "name": "React Native",
                        "icon": "react.png",
                        "url": "https://reactnative.dev/"
                    },
                    {
                        "name": "Expo",
                        "icon": "expo.png",
                        "url": "https://expo.dev/"
                    },
                    {
                        "name": "Golang",
                        "icon": "golang.png",
                        "url": "https://golang.org/"
                    },
                    {
                        "name": "MongoDB",
                        "icon": "mongodb.png",
                        "url": "https://www.mongodb.com/"
                    }
                ]
            }
        ]
    },
    "games": {
        "type": "GroupsSection",
        "title": "Videojuegos",
        "elements" : [
            {
                "title": "Froggy Against the World",
                "description": "Juego de ritmo para dispositivos móviles (hecho en Godot 3).",
                "url": "https://bluemili.itch.io/froggy-against-the-world",
                "technologies": [
                    {
                        "name": "Godot",
                        "icon": "godot.png",
                        "url": "https://godotengine.org/"
                    }
                ]
            },
            {
                "title": "Chaotic Ocean",
                "description": "Juego multijugador de 2 a 4 jugadores (hecho en Godot 4).",
                "url": "https://bluemili.itch.io/chaotic-ocean",
                "technologies": [
                    {
                        "name": "Godot",
                        "icon": "godot.png",
                        "url": "https://godotengine.org/"
                    }
                ]
            }
        ]
    },
    "ML": {
        "type": "GroupsSection",
        "title": "Machine Learning",
        "elements" : [
            {
                "title": "Análisis de pobreza en Chile a partir de encuestas CASEN",
                "description": "Para el curso de 'Minería de Datos' realizamos un análisis de los datos de las encuestas CASEN, usando distintos algoritmos de clasificación (ej: KNN, Naive Bayes, Random Forest, etc) y de clustering (ej: DBScan, Kmeans). Se utilizó Python y las librerías scikit-learn, pandas, numpy, matplotlib y seaborn. Se puede encontrar tanto los reportes de las 3 iteraciones como el código, en el siguiente enlace.",
                "url": "https://f-escarate.cl/AnalisisCasen.html"
            },
            {
                "title": "Competencias Procesamiento del Lenguaje Natural",
                "description": "En el contexto del curso de 'Procesamiento del Lenguaje Natural' se realizaron dos competencias, la primera se trataba sobre clasificar un tweets chilenos según 3 categorías: discurso de odio, incivilidad o normal. Si bien probamos distintos modelos (BERT, LSTM, GRU, etc), lo que nos dio mejores resultados fue utilizar un stacking de los modelos más simples que probamos, i.e: Naive Bayes, SVM, MLP, ExtraTrees, CatBoost y LightGBM..\n\n La segunda competencia consistió en una tarea tipo NER (Name Entity Recognition) usando un corpus de listas de espera, las cuales tenían las entidades [Disease, Body_Part, Medication, Procedures y Family_Member]. Se usararon GRU, LSTM y distintas versiones de BERT, sin embargo todas entregaban resultados similares. También se probó usando capas de embeddings en español, pero esto no mejoró mucho los resultados."
            }
        ]
    }
}